{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"./IERC1155.sol\";\nimport {IERC1155Receiver} from \"./IERC1155Receiver.sol\";\nimport {IERC1155MetadataURI} from \"./extensions/IERC1155MetadataURI.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {Arrays} from \"../../utils/Arrays.sol\";\nimport {IERC1155Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    mapping(uint256 id => mapping(address account => uint256)) private _balances;\n\n    mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     */\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = _balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    _balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                _balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                _doSafeTransferAcceptanceCheck(operator, from, to, id, value, data);\n            } else {\n                _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Performs an acceptance check by calling {IERC1155-onERC1155Received} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check by calling {IERC1155-onERC1155BatchReceived} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/art/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678\" \"9+/\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n        string memory table = TABLE;\n        uint256 encodedLength = ((data.length + 2) / 3) << 2;\n        string memory result = new string(encodedLength + 0x20);\n\n        assembly {\n            mstore(result, encodedLength)\n            let tablePtr := add(table, 1)\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            let resultPtr := add(result, 0x20)\n            for {} lt(dataPtr, endPtr) {} {\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(shr(0x12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(shr(0xC, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(0xF0, 0x3D3D)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(0xF8, 0x3D)) }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/art/Chess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Engine} from \"./Engine.sol\";\n\n/// @title Utils library for fiveoutofnine (a 100% on-chain 6x6 chess engine)\n/// @author fiveoutofnine\n/// @dev Understand the representations of the chess pieces, board, and moves very carefully before\n/// using this library:\n/// ======================================Piece Representation======================================\n/// Each chess piece is defined with 4 bits as follows:\n///     * The first bit denotes the color (0 means black; 1 means white).\n///     * The last 3 bits denote the type:\n///         | Bits | # | Type   |\n///         | ---- | - | ------ |\n///         | 000  | 0 | Empty  |\n///         | 001  | 1 | Pawn   |\n///         | 010  | 2 | Bishop |\n///         | 011  | 3 | Rook   |\n///         | 100  | 4 | Knight |\n///         | 101  | 5 | Queen  |\n///         | 110  | 6 | King   |\n/// ======================================Board Representation======================================\n/// The board is an 8x8 representation of a 6x6 chess board. For efficiency, all information is\n/// bitpacked into a single uint256. Thus, unlike typical implementations, board positions are\n/// accessed via bit shifts and bit masks, as opposed to array accesses. Since each piece is 4 bits,\n/// there are 64 ``indices'' to access: # 256bit interger, 4 bits per piece each 4bits represents a slot on the board\n///                                     63 62 61 60 59 58 57 56\n///                                     55 54 53 52 51 50 49 48\n///                                     47 46 45 44 43 42 41 40\n///                                     39 38 37 36 35 34 33 32\n///                                     31 30 29 28 27 26 25 24\n///                                     23 22 21 20 19 18 17 16\n///                                     15 14 13 12 11 10 09 08\n///                                     07 06 05 04 03 02 01 00\n/// All numbers in the figure above are in decimal representation.\n/// For example, the piece at index 27 is accessed with ``(board >> (27 << 2)) & 0xF''. \n\n/// 00... 0110 # Board with black king at index 00\n/// 00... 0110 >> 0 << 2 & 1111\n///  00... 0110 >> 0  =  00...0110 \n//// 00... 0110 << 2  -> 00 ... 01100  \n//// 00 ... 0000 1100 & (1111) -> 0000 1100\n/// \n/// The top/bottom rows and left/right columns are treated as sentinel rows/columns for efficient\n/// boundary validation (see {Chess-generateMoves} and {Chess-isValid}). i.e., (63, ..., 56),\n/// (07, ..., 00), (63, ..., 07), and (56, ..., 00) never contain pieces. Every bit in those rows\n/// and columns should be ignored, except for the last bit. The last bit denotes whose turn it is to\n/// play (0 means black's turn; 1 means white's turn). e.g. a potential starting position:\n///                                Black\n///                       00 00 00 00 00 00 00 00                    Black\n///                       00 03 02 05 06 02 03 00                 ♜ ♝ ♛ ♚ ♝ ♜\n///                       00 01 01 01 01 01 01 00                 ♟ ♟ ♟ ♟ ♟ ♟\n///                       00 00 00 00 00 00 00 00     denotes\n///                       00 00 00 00 00 00 00 00    the board\n///                       00 09 09 09 09 09 09 00                 ♙ ♙ ♙ ♙ ♙ ♙\n///                       00 11 12 13 14 12 11 00                 ♖ ♘ ♕ ♔ ♘ ♖\n///                       00 00 00 00 00 00 00 01                    White\n///                                White\n/// All numbers in the example above are in decimal representation.\n/// ======================================Move Representation=======================================\n/// Each move is allocated 12 bits. The first 6 bits are the index the piece is moving from, and the\n/// last 6 bits are the index the piece is moving to. Since the index representing a square is at\n/// most 54, 6 bits sufficiently represents any index (0b111111 = 63 > 54). e.g. 1243 denotes a move\n/// from index 19 to 27 (1243 = (19 << 6) | 27).\n///\n/// Since the board is represented by a uint256, consider including ``using Chess for uint256''.\nlibrary Chess {\n    using Chess for uint256;\n    using Chess for Chess.MovesArray;\n\n    /// The depth, white's move, and black's move are bitpacked in that order as `metadata` for\n    /// efficiency. As explained above, 12 bits sufficiently describe a move, so both white's and\n    /// black's moves are allocated 12 bits each.\n    struct Move {\n        uint256 board;\n        uint256 metadata;\n    }\n\n    /// ``moves'' are bitpacked into uint256s for efficiency. Since every move is defined by at most\n    /// 12 bits, a uint256 can contain up to 21 moves via bitpacking (21 * 12 = 252 < 256).\n    /// Therefore, `items` can contain up to 21 * 5 = 105 moves. 105 is a safe upper bound for the\n    /// number of possible moves a given side may have during a real game, but be wary because there\n    /// is no formal proof of the upper bound being less than or equal to 105.\n    struct MovesArray {\n        uint256 index;\n        uint256[5] items;\n    }\n\n    /// @notice Takes in a board position, and applies the move `_move` to it.\n    /// @dev After applying the move, the board's perspective is updated (see {rotate}). Thus,\n    /// engines with symmterical search algorithms -- like negamax search -- probably work best.\n    /// @param _board The board to apply the move to.\n    /// @param _move The move to apply.\n    /// @return The reversed board after applying `_move` to `_board`.\n    function applyMove(uint256 _board, uint256 _move) internal pure returns (uint256) {\n        unchecked {\n            // Get piece at the from index\n            uint256 piece = (_board >> ((_move >> 6) << 2)) & 0xF;\n            // Replace 4 bits at the from index with 0000\n            _board &= type(uint256).max ^ (0xF << ((_move >> 6) << 2));\n            // Replace 4 bits at the to index with 0000\n            _board &= type(uint256).max ^ (0xF << ((_move & 0x3F) << 2));\n            // Place the piece at the to index\n            _board |= (piece << ((_move & 0x3F) << 2));\n\n            return _board.rotate();\n        }\n    }\n\n    /// @notice Switches the perspective of the board by reversing its 4-bit subdivisions (e.g.\n    /// 1100-0011 would become 0011-1100).\n    /// @dev Since the last bit exchanges positions with the 4th bit, the turn identifier is updated\n    /// as well.\n    /// @param _board The board to reverse the perspective on.\n    /// @return `_board` reversed.\n    function rotate(uint256 _board) internal pure returns (uint256) {\n        uint256 rotatedBoard;\n\n        unchecked {\n            for (uint256 i; i < 64; ++i) {\n                rotatedBoard = (rotatedBoard << 4) | (_board & 0xF);\n                _board >>= 4;\n            }\n        }\n\n        return rotatedBoard;\n    }\n\n    /// @notice Generates all possible pseudolegal moves for a given position and color.\n    /// @dev The last bit denotes which color to generate the moves for (see {Chess}). Also, the\n    /// function errors if more than 105 moves are found (see {Chess-MovesArray}). All moves are\n    /// expressed in code as shifts respective to the board's 8x8 representation (see {Chess}).\n    /// @param _board The board position to generate moves for.\n    /// @return Bitpacked uint256(s) containing moves.\n    function generateMoves(uint256 _board) internal pure returns (uint256[5] memory) {\n        Chess.MovesArray memory movesArray;\n        uint256 move;\n        uint256 moveTo;\n\n        unchecked {\n            // `0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289` is a mapping of indices\n            // relative to the 6x6 board to indices relative to the 8x8 representation (see\n            // {Chess-getAdjustedIndex}).\n            for (uint256 index = 0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289; index != 0; index >>= 6) {\n                uint256 adjustedIndex = index & 0x3F;\n                uint256 adjustedBoard = _board >> (adjustedIndex << 2);\n                uint256 piece = adjustedBoard & 0xF;\n                // Skip if square is empty or not the color of the board the function call is\n                // analyzing.\n                if (piece == 0 || piece >> 3 != _board & 1) continue;\n                // The first bit can be discarded because the if statement above catches all\n                // redundant squares.\n                piece &= 7;\n\n                if (piece == 1) {\n                    // Piece is a pawn.\n                    // 1 square in front of the pawn is empty.\n                    if ((adjustedBoard >> 0x20) & 0xF == 0) {\n                        movesArray.append(adjustedIndex, adjustedIndex + 8);\n                        // The pawn is in its starting row and 2 squares in front is empty. This\n                        // must be nested because moving 2 squares would not be valid if there was\n                        // an obstruction 1 square in front (i.e. pawns can not jump over pieces).\n                        if (adjustedIndex >> 3 == 2 && (adjustedBoard >> 0x40) & 0xF == 0) {\n                            movesArray.append(adjustedIndex, adjustedIndex + 0x10);\n                        }\n                    }\n                    // Moving to the right diagonal by 1 captures a piece.\n                    if (_board.isCapture(adjustedBoard >> 0x1C)) {\n                        movesArray.append(adjustedIndex, adjustedIndex + 7);\n                    }\n                    // Moving to the left diagonal by 1 captures a piece.\n                    if (_board.isCapture(adjustedBoard >> 0x24)) {\n                        movesArray.append(adjustedIndex, adjustedIndex + 9);\n                    }\n                } else if (piece > 3 && piece & 1 == 0) {\n                    // Piece is a knight or a king.\n                    // Knights and kings always only have 8 positions to check relative to their\n                    // current position, and the relative distances are always the same. For\n                    // knights, positions to check are ±{6, 10, 15, 17}. This is bitpacked into\n                    // `0x060A0F11` to reduce code redundancy. Similarly, the positions to check for\n                    // kings are ±{1, 7, 8, 9}, which is `0x01070809` when bitpacked.\n                    for (move = piece == 4 ? 0x060A0F11 : 0x01070809; move != 0; move >>= 8) {\n                        if (_board.isValid(moveTo = adjustedIndex + (move & 0xFF))) {\n                            movesArray.append(adjustedIndex, moveTo);\n                        }\n                        if (move <= adjustedIndex && _board.isValid(moveTo = adjustedIndex - (move & 0xFF))) {\n                            movesArray.append(adjustedIndex, moveTo);\n                        }\n                    }\n                } else {\n                    // This else block generates moves for all sliding pieces. All of the 8 for\n                    // loops terminate\n                    //     * before a sliding piece makes an illegal move\n                    //     * or after a sliding piece captures a piece.\n                    if (piece != 2) {\n                        // Ortholinear pieces (i.e. rook and queen)\n                        for (move = adjustedIndex + 1; _board.isValid(move); move += 1) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 1; _board.isValid(move); move -= 1) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex + 8; _board.isValid(move); move += 8) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 8; _board.isValid(move); move -= 8) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                    }\n                    if (piece != 3) {\n                        // Diagonal pieces (i.e. bishop and queen)\n                        for (move = adjustedIndex + 7; _board.isValid(move); move += 7) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 7; _board.isValid(move); move -= 7) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex + 9; _board.isValid(move); move += 9) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 9; _board.isValid(move); move -= 9) {\n                            // Handles the edge case where a white bishop believes it can capture\n                            // the ``piece'' at index 0, when it is actually the turn identifier It\n                            // would mistakenly believe it is valid move via capturing a black pawn.\n                            if (move == 0) break;\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return movesArray.items;\n    }\n\n    /// @notice Determines whether a move is a legal move or not (includes checking whether king is\n    /// checked or not after the move).\n    /// @param _board The board to analyze.\n    /// @param _move The move to check.\n    /// @return Whether the move is legal or not.\n    function isLegalMove(uint256 _board, uint256 _move) internal pure returns (bool) {\n        unchecked {\n            uint256 fromIndex = _move >> 6;\n            uint256 toIndex = _move & 0x3F;\n            if ((0x7E7E7E7E7E7E00 >> fromIndex) & 1 == 0) return false;\n            if ((0x7E7E7E7E7E7E00 >> toIndex) & 1 == 0) return false;\n\n            uint256 pieceAtFromIndex = (_board >> (fromIndex << 2)) & 0xF;\n            if (pieceAtFromIndex == 0) return false;\n            if (pieceAtFromIndex >> 3 != _board & 1) return false;\n            pieceAtFromIndex &= 7;\n\n            uint256 adjustedBoard = _board >> (toIndex << 2);\n            uint256 indexChange = toIndex < fromIndex ? fromIndex - toIndex : toIndex - fromIndex;\n            if (pieceAtFromIndex == 1) {\n                if (toIndex <= fromIndex) return false;\n                indexChange = toIndex - fromIndex;\n                if ((indexChange == 7 || indexChange == 9)) {\n                    if (!_board.isCapture(adjustedBoard)) return false;\n                } else if (indexChange == 8) {\n                    if (!isValid(_board, toIndex)) return false;\n                } else if (indexChange == 0x10) {\n                    if (!isValid(_board, toIndex - 8) || !isValid(_board, toIndex)) return false;\n                } else {\n                    return false;\n                }\n            } else if (pieceAtFromIndex == 4 || pieceAtFromIndex == 6) {\n                if (((pieceAtFromIndex == 4 ? 0x28440 : 0x382) >> indexChange) & 1 == 0) {\n                    return false;\n                }\n                if (!isValid(_board, toIndex)) return false;\n            } else {\n                bool rayFound;\n                if (pieceAtFromIndex != 2) {\n                    rayFound = searchRay(_board, fromIndex, toIndex, 1) || searchRay(_board, fromIndex, toIndex, 8);\n                }\n                if (pieceAtFromIndex != 3) {\n                    rayFound =\n                        rayFound || searchRay(_board, fromIndex, toIndex, 7) || searchRay(_board, fromIndex, toIndex, 9);\n                }\n                if (!rayFound) return false;\n            }\n\n            if (Engine.negaMax(_board.applyMove(_move), 1) < -1_260) return false;\n\n            return true;\n        }\n    }\n\n    /// @notice Determines whether there is a clear path along a direction vector from one index to\n    /// another index on the board.\n    /// @dev The board's representation essentially flattens it from 2D to 1D, so `_directionVector`\n    /// should be the change in index that represents the direction vector.\n    /// @param _board The board to analyze.\n    /// @param _fromIndex The index of the starting piece.\n    /// @param _toIndex The index of the ending piece.\n    /// @param _directionVector The direction vector of the ray.\n    /// @return Whether there is a clear path between `_fromIndex` and `_toIndex` or not.\n    function searchRay(uint256 _board, uint256 _fromIndex, uint256 _toIndex, uint256 _directionVector)\n        internal\n        pure\n        returns (bool)\n    {\n        unchecked {\n            uint256 indexChange;\n            uint256 rayStart;\n            uint256 rayEnd;\n            if (_fromIndex < _toIndex) {\n                indexChange = _toIndex - _fromIndex;\n                rayStart = _fromIndex + _directionVector;\n                rayEnd = _toIndex;\n            } else {\n                indexChange = _fromIndex - _toIndex;\n                rayStart = _toIndex;\n                rayEnd = _fromIndex - _directionVector;\n            }\n            if (indexChange % _directionVector != 0) return false;\n\n            for (rayStart = rayStart; rayStart < rayEnd; rayStart += _directionVector) {\n                if (!isValid(_board, rayStart)) return false;\n                if (isCapture(_board, _board >> (rayStart << 2))) return false;\n            }\n\n            if (!isValid(_board, rayStart)) return false;\n\n            return rayStart == rayEnd;\n        }\n    }\n\n    /// @notice Determines whether a move results in a capture or not.\n    /// @param _board The board prior to the potential capture.\n    /// @param _indexAdjustedBoard The board bitshifted to the to index to consider.\n    /// @return Whether the move is a capture or not.\n    function isCapture(uint256 _board, uint256 _indexAdjustedBoard) internal pure returns (bool) {\n        unchecked {\n            return (_indexAdjustedBoard & 0xF) != 0 // The square is not empty.\n                && (_indexAdjustedBoard & 0xF) >> 3 != _board & 1; // The piece is opposite color.\n        }\n    }\n\n    /// @notice Determines whether a move is valid or not (i.e. within bounds and not capturing\n    /// same colored piece).\n    /// @dev As mentioned above, the board representation has 2 sentinel rows and columns for\n    /// efficient boundary validation as follows:\n    ///                                           0 0 0 0 0 0 0 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 0 0 0 0 0 0 0,\n    /// where 1 means a piece is within the board, and 0 means the piece is out of bounds. The bits\n    /// are bitpacked into a uint256 (i.e. ``0x7E7E7E7E7E7E00 = 0 << 63 | ... | 0 << 0'') for\n    /// efficiency.\n    ///\n    /// Moves that overflow the uint256 are computed correctly because bitshifting more than bits\n    /// available results in 0. However, moves that underflow the uint256 (i.e. applying the move\n    /// results in a negative index) must be checked beforehand.\n    /// @param _board The board on which to consider whether the move is valid.\n    /// @param _toIndex The to index of the move.\n    /// @return Whether the move is valid or not.\n    function isValid(uint256 _board, uint256 _toIndex) internal pure returns (bool) {\n        unchecked {\n            return (0x7E7E7E7E7E7E00 >> _toIndex) & 1 == 1 // Move is within bounds.\n                && (\n                    (_board >> (_toIndex << 2)) & 0xF == 0 // Square is empty.\n                        || (((_board >> (_toIndex << 2)) & 0xF) >> 3) != _board & 1\n                ); // Piece captured.\n        }\n    }\n\n    /// @notice Maps an index relative to the 6x6 board to the index relative to the 8x8\n    /// representation.\n    /// @dev The indices are mapped as follows:\n    ///                           35 34 33 32 31 30              54 53 52 51 50 49\n    ///                           29 28 27 26 25 24              46 45 44 43 42 41\n    ///                           23 22 21 20 19 18    mapped    38 37 36 35 34 33\n    ///                           17 16 15 14 13 12      to      30 29 28 27 26 25\n    ///                           11 10 09 08 07 06              22 21 20 19 18 17\n    ///                           05 04 03 02 01 00              14 13 12 11 10 09\n    /// All numbers in the figure above are in decimal representation. The bits are bitpacked into a\n    /// uint256 (i.e. ``0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289 = 54 << (6 * 35) |\n    /// ... | 9 << (6 * 0)'') for efficiency.\n    /// @param _index Index relative to the 6x6 board.\n    /// @return Index relative to the 8x8 representation.\n    function getAdjustedIndex(uint256 _index) internal pure returns (uint256) {\n        unchecked {\n            return ((0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289 >> (_index * 6)) & 0x3F);\n        }\n    }\n\n    /// @notice Appends a move to a {Chess-MovesArray} object.\n    /// @dev Since each uint256 fits at most 21 moves (see {Chess-MovesArray}), {Chess-append}\n    /// bitpacks 21 moves per uint256 before moving on to the next uint256.\n    /// @param _movesArray {Chess-MovesArray} object to append the new move to.\n    /// @param _fromMoveIndex Index the piece moves from.\n    /// @param _toMoveIndex Index the piece moves to.\n    function append(MovesArray memory _movesArray, uint256 _fromMoveIndex, uint256 _toMoveIndex) internal pure {\n        unchecked {\n            uint256 currentIndex = _movesArray.index;\n            uint256 currentPartition = _movesArray.items[currentIndex];\n\n            if (currentPartition > (1 << 0xF6)) {\n                _movesArray.items[++_movesArray.index] = (_fromMoveIndex << 6) | _toMoveIndex;\n            } else {\n                _movesArray.items[currentIndex] = (currentPartition << 0xC) | (_fromMoveIndex << 6) | _toMoveIndex;\n            }\n        }\n    }\n}\n"
    },
    "contracts/art/Engine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Chess} from \"./Chess.sol\";\n\n/// @title A 6x6 chess engine with negamax search\n/// @author fiveoutofnine\n/// @notice Docstrings below are written from the perspective of black (i.e. written as if the\n/// engine is always black). However, due to negamax's symmetric nature, the engine may be used for\n/// white as well.\nlibrary Engine {\n    using Chess for uint256;\n    using Engine for uint256;\n\n    /// @notice Searches for the ``best'' move.\n    /// @dev The ply depth must be at least 3 because game ending scenarios are determined lazily.\n    /// This is because {generateMoves} generates pseudolegal moves. Consider the following:\n    ///     1. In the case of white checkmates black, depth 2 is necessary:\n    ///         * Depth 1: This is the move black plays after considering depth 2.\n    ///         * Depth 2: Check whether white captures black's king within 1 turn for every such\n    ///           move. If so, white has checkmated black.\n    ///     2. In the case of black checkmates white, depth 3 is necessary:\n    ///         * Depth 1: This is the move black plays after considering depths 2 and 3.\n    ///         * Depth 2: Generate all pseudolegal moves for white in response to black's move.\n    ///         * Depth 3: Check whether black captures white's king within 1 turn for every such\n    ///         * move. If so, black has checkmated white.\n    /// The minimum depth required to cover all the cases above is 3. For simplicity, stalemates\n    /// are treated as checkmates.\n    ///\n    /// The function returns 0 if the game is over after white's move (no collision with any\n    /// potentially real moves because 0 is not a valid index), and returns true if the game is over\n    /// after black's move.\n    /// @param _board The board position to analyze.\n    /// @param _depth The ply depth to analyze to. Must be at least 3.\n    /// @return The best move for the player (denoted by the last bit in `_board`).\n    /// @return Whether white is checkmated or not.\n    function searchMove(uint256 _board, uint256 _depth) internal pure returns (uint256, bool) {\n        uint256[5] memory moves = _board.generateMoves();\n        if (moves[0] == 0) return (0, false);\n        // See {Engine-negaMax} for explanation on why `bestScore` is set to -4_196.\n        int256 bestScore = -4_196;\n        int256 currentScore;\n        uint256 bestMove;\n\n        unchecked {\n            for (uint256 i; moves[i] != 0; ++i) {\n                for (uint256 movePartition = moves[i]; movePartition != 0; movePartition >>= 0xC) {\n                    currentScore = _board.evaluateMove(movePartition & 0xFFF)\n                        + negaMax(_board.applyMove(movePartition & 0xFFF), _depth - 1);\n                    if (currentScore > bestScore) {\n                        bestScore = currentScore;\n                        bestMove = movePartition & 0xFFF;\n                    }\n                }\n            }\n        }\n\n        // 1_260 is equivalent to 7 queens (7 * 180 = 1260). Since a king's capture is equivalent to\n        // an evaluation of 4_000, ±1_260 catches all lines that include the capture of a king.\n        if (bestScore < -1_260) return (0, false);\n        return (bestMove, bestScore > 1_260);\n    }\n\n    /// @notice Searches and evaluates moves using a variant of the negamax search algorithm.\n    /// @dev For efficiency, the function evaluates how good moves are and sums them up, rather than\n    /// evaluating entire board positions. Thus, the only pruning the algorithm performs is when a\n    /// king is captured. If a king is captured, it always returns -4,000, which is the king's value\n    /// (see {Chess}) because there is nothing more to consider.\n    /// @param _board The board position to analyze.\n    /// @param _depth The ply depth to analyze to.\n    /// @return The cumulative score searched to a ply depth of `_depth`, assuming each side picks\n    /// their ``best'' (as decided by {Engine-evaluateMove}) moves.\n    function negaMax(uint256 _board, uint256 _depth) internal pure returns (int256) {\n        // Base case for the recursion.\n        if (_depth == 0) return 0;\n        uint256[5] memory moves = _board.generateMoves();\n        // There is no ``best'' score if there are no moves to play.\n        if (moves[0] == 0) return 0;\n        // `bestScore` is initially set to -4_196 because no line will result in a cumulative\n        // evaluation of <-4_195. -4_195 occurs, for example. when the engine's king is captured\n        // (-4000), and the player captures an engine's queen on index 35 (-181) with knight from\n        // index 52 (-14).\n        int256 bestScore = -4_196;\n        int256 currentScore;\n        uint256 bestMove;\n\n        unchecked {\n            for (uint256 i; moves[i] != 0; ++i) {\n                for (uint256 movePartition = moves[i]; movePartition != 0; movePartition >>= 0xC) {\n                    currentScore = _board.evaluateMove(movePartition & 0xFFF);\n                    if (currentScore > bestScore) {\n                        bestScore = currentScore;\n                        bestMove = movePartition & 0xFFF;\n                    }\n                }\n            }\n\n            // If a king is captured, stop the recursive call stack and return a score of -4_000.\n            // There is nothing more to consider.\n            if (((_board >> ((bestMove & 0x3F) << 2)) & 7) == 6) return -4_000;\n            return _board & 1 == 0\n                ? bestScore + negaMax(_board.applyMove(bestMove), _depth - 1)\n                : -bestScore + negaMax(_board.applyMove(bestMove), _depth - 1);\n        }\n    }\n\n    /// @notice Uses piece-square tables (PSTs) to evaluate how ``good'' a move is.\n    /// @dev The PSTs were selected semi-arbitrarily with chess strategies in mind (e.g. pawns are\n    /// good in the center). Updating them changes the way the engine ``thinks.'' Each piece's PST\n    /// is bitpacked into as few uint256s as possible for efficiency (see {Engine-getPst} and\n    /// {Engine-getPstTwo}):\n    ///          Pawn                Bishop               Knight                   Rook\n    ///    20 20 20 20 20 20    62 64 64 64 64 62    54 56 54 54 56 58    100 100 100 100 100 100\n    ///    30 30 30 30 30 30    64 66 66 66 66 64    56 60 64 64 60 56    101 102 102 102 102 101\n    ///    20 22 24 24 22 20    64 67 68 68 67 64    58 64 68 68 64 58     99 100 100 100 100  99\n    ///    21 20 26 26 20 21    64 68 68 68 68 64    58 65 68 68 65 58     99 100 100 100 100  99\n    ///    21 30 16 16 30 21    64 67 66 66 67 64    56 60 65 65 60 56     99 100 100 100 100  99\n    ///    20 20 20 20 20 20    62 64 64 64 64 62    54 56 58 58 56 54    100 100 101 101 100 100\n    ///                            Queen                         King\n    ///                   176 178 179 179 178 176    3994 3992 3990 3990 3992 3994\n    ///                   178 180 180 180 180 178    3994 3992 3990 3990 3992 3994\n    ///                   179 180 181 181 180 179    3996 3994 3992 3992 3994 3995\n    ///                   179 181 181 181 180 179    3998 3996 3996 3996 3996 3998\n    ///                   178 180 181 180 180 178    4001 4001 4000 4000 4001 4001\n    ///                   176 178 179 179 178 176    4004 4006 4002 4002 4006 4004\n    /// All entries in the figure above are in decimal representation.\n    ///\n    /// Each entry in the pawn's, bishop's, knight's, and rook's PSTs uses 7 bits, and each entry in\n    /// the queen's and king's PSTs uses 12 bits. Additionally, each piece is valued as following:\n    ///                                      | Type   | Value |\n    ///                                      | ------ | ----- |\n    ///                                      | Pawn   | 20    |\n    ///                                      | Bishop | 66    |\n    ///                                      | Knight | 64    |\n    ///                                      | Rook   | 100   |\n    ///                                      | Queen  | 180   |\n    ///                                      | King   | 4000  |\n    /// The king's value just has to be sufficiently larger than 180 * 7 = 1260 (i.e. equivalent to\n    /// 7 queens) because check/checkmates are detected lazily (see {Engine-generateMoves}).\n    ///\n    /// The evaluation of a move is given by\n    ///                Δ(PST value of the moved piece) + (PST value of any captured pieces).\n    /// @param _board The board to apply the move to.\n    /// @param _move The move to evaluate.\n    /// @return The evaluation of the move applied to the given position.\n    function evaluateMove(uint256 _board, uint256 _move) internal pure returns (int256) {\n        unchecked {\n            uint256 fromIndex = 6 * (_move >> 9) + ((_move >> 6) & 7) - 7;\n            uint256 toIndex = 6 * ((_move & 0x3F) >> 3) + ((_move & 0x3F) & 7) - 7;\n            uint256 pieceAtFromIndex = (_board >> ((_move >> 6) << 2)) & 7;\n            uint256 pieceAtToIndex = (_board >> ((_move & 0x3F) << 2)) & 7;\n            uint256 oldPst;\n            uint256 newPst;\n            uint256 captureValue;\n\n            if (pieceAtToIndex != 0) {\n                if (pieceAtToIndex < 5) {\n                    // Piece is not a queen or king\n                    captureValue = (getPst(pieceAtToIndex) >> (7 * (0x23 - toIndex))) & 0x7F;\n                } else if (toIndex < 0x12) {\n                    // Piece is queen or king and in the closer half\n                    captureValue = (getPst(pieceAtToIndex) >> (0xC * (0x11 - toIndex))) & 0xFFF;\n                } else {\n                    // Piece is queen or king and in the further half\n                    captureValue = (getPstTwo(pieceAtToIndex) >> (0xC * (0x23 - toIndex))) & 0xFFF;\n                }\n            }\n            if (pieceAtFromIndex < 5) {\n                // Piece is not a queen or king\n                oldPst = (getPst(pieceAtFromIndex) >> (7 * fromIndex)) & 0x7F;\n                newPst = (getPst(pieceAtFromIndex) >> (7 * toIndex)) & 0x7F;\n            } else if (fromIndex < 0x12) {\n                // Piece is queen or king and in the closer half\n                oldPst = (getPstTwo(pieceAtFromIndex) >> (0xC * fromIndex)) & 0xFFF;\n                newPst = (getPstTwo(pieceAtFromIndex) >> (0xC * toIndex)) & 0xFFF;\n            } else {\n                // Piece is queen or king and in the further half\n                oldPst = (getPst(pieceAtFromIndex) >> (0xC * (fromIndex - 0x12))) & 0xFFF;\n                newPst = (getPst(pieceAtFromIndex) >> (0xC * (toIndex - 0x12))) & 0xFFF;\n            }\n\n            return int256(captureValue + newPst) - int256(oldPst);\n        }\n    }\n\n    /// @notice Maps a given piece type to its PST (see {Engine-evaluateMove} for details on the\n    /// PSTs and {Chess} for piece representation).\n    /// @dev The queen's and king's PSTs do not fit in 1 uint256, so their PSTs are split into 2\n    /// uint256s each. {Chess-getPst} contains the first half, and {Chess-getPstTwo} contains the\n    /// second half.\n    /// @param _type A piece type defined in {Chess}.\n    /// @return The PST corresponding to `_type`.\n    function getPst(uint256 _type) internal pure returns (uint256) {\n        if (_type == 1) return 0x2850A142850F1E3C78F1E2858C182C50A943468A152A788103C54A142850A14;\n        if (_type == 2) return 0x7D0204080FA042850A140810E24487020448912240810E1428701F40810203E;\n        if (_type == 3) return 0xC993264C9932E6CD9B365C793264C98F1E4C993263C793264C98F264CB97264;\n        if (_type == 4) return 0x6CE1B3670E9C3C8101E38750224480E9D4189120BA70F20C178E1B3874E9C36;\n        if (_type == 5) return 0xB00B20B30B30B20B00B20B40B40B40B40B20B30B40B50B50B40B3;\n        return 0xF9AF98F96F96F98F9AF9AF98F96F96F98F9AF9CF9AF98F98F9AF9B;\n    }\n\n    /// @notice Maps a queen or king to the second half of its PST (see {Engine-getPst}).\n    /// @param _type A piece type defined in {Chess}. Must be a queen or a king (see\n    /// {Engine-getPst}).\n    /// @return The PST corresponding to `_type`.\n    function getPstTwo(uint256 _type) internal pure returns (uint256) {\n        return _type == 5\n            ? 0xB30B50B50B50B40B30B20B40B50B40B40B20B00B20B30B30B20B0\n            : 0xF9EF9CF9CF9CF9CF9EFA1FA1FA0FA0FA1FA1FA4FA6FA2FA2FA6FA4;\n    }\n}\n"
    },
    "contracts/art/fiveOutOfNineArt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport {Chess} from \"./Chess.sol\";\nimport {Base64} from \"./Base64.sol\";\n\n/// @title A library that generates HTML art for fiveoutofnine (an on-chain 6x6 chess engine)\n/// @author fiveoutofnine\n/// @notice Below details how the metadata and art are generated:\n/// ==============================================Name==============================================\n/// Expressed as Python3 f-strings below, token names generate as\n///                     ``f\"fiveoutofnine - Game #{game_id}, Move #{move_id}\"''.\n/// ==========================================Description===========================================\n/// Token descriptions describe white's move in algebraic notation and black's move in algebraic\n/// notation. If white's move results in checkmating black or a stalemate, the description will say\n/// black resigned (for simplicity, stalemates are treated as checkmates). Since the engine always\n/// plays black, and the player always plays white, white is indicated as ``Player'', and black is\n/// indicated as ``fiveoutofnine''. Additionally, for every non game-ending turn, a string graphic\n/// is generated after the moves' descriptions. An example:\n///                             Player plays e4 rook captures e5 queen.\n///                             6 · · ♜ · ♚ ♜\n///                             5 · ♟ · · ♖ ♟\n///                             4 ♟ ♙ ♟ ♙ * ♙\n///                             3 ♙ · ♙ · · ·\n///                             2 · · · · ♖ ·\n///                             1 · ♘ · ♔ · ·\n///                               a b c d e f\n///\n///                             fiveoutofnine resigns.\n/// * indicates the square the piece moved from.\n/// ==============================================Art===============================================\n/// The art is generated as HTML code with in-line CSS (0 JS) according to the following table:\n///  | Property       | Name      | Value/Description                       | Determination       |\n///  | ============== | ========= | ======================================= | =================== |\n///  | Dimension      | 1 × 1     | 1 × 1 pillars                           | Player moved king   |\n///  | (6 traits)     | 2 × 2     | 2 × 2 pillars                           | Player moved rook   |\n///  |                | 3 × 3     | 3 × 3 pillars                           | Engine moved bishop |\n///  |                | 4 × 4     | 4 × 4 pillars                           | Player moved knight |\n///  |                | 6 × 6     | 6 × 6 pillars                           | Player moved pawn   |\n///  |                | 12 × 12   | 12 × 12 pillars                         | Player moved queen  |\n///  | -------------- | --------- | --------------------------------------- | ------------------- |\n///  | Height         | Plane     | 8px pillar height                       | 1 / 64 chance[^0]   |\n///  | (5 traits)     | 1/4       | 98px pillar height                      | 10 / 64 chance[^0]  |\n///  |                | 1/2       | 197px pillar height                     | 10 / 64 chance[^0]  |\n///  |                | Cube      | 394px pillar height                     | 40 / 64 chance[^0]  |\n///  |                | Infinite  | 1000px pillar height                    | 3 / 64 chance[^0]   |\n///  | -------------- | --------- | --------------------------------------- | ------------------- |\n///  | Gap[^1]        | None      | 0px gap between the pillars             | 4 / 16 chance[^0]   |\n///  | (4 traits)     | Narrow    | 2px gap between the pillars             | 9 / 16 chance[^0]   |\n///  |                | Wide      | 12px gap between the pillars            | 2 / 16 chance[^0]   |\n///  |                | Ultrawide | 24px gap between the pillars            | 1 / 16 chance[^0]   |\n///  | -------------- | --------- | --------------------------------------- | ------------------- |\n///  | Color          | Uniform   | All faces are the same color            | 7 / 32 chance[^0]   |\n///  | Generation[^2] | Shades    | Faces get darker anticlockwise          | 7 / 32 chance[^0]   |\n///  | (6 traits)     | Tints     | Faces get lighter anticlockwise         | 7 / 32 chance[^0]   |\n///  |                | Eclipse   | Left face is white; black face is black | 3 / 32 chance[^0]   |\n///  |                | Void      | Left and right face are black           | 1 / 32 chance[^0]   |\n///  |                | Curated   | One of 8 color themes (see below)       | 7 / 32 chance[^0]   |\n///  | -------------- | --------- | --------------------------------------- | ------------------- |\n///  | Color          | Nord      | 0x8FBCBBEBCB8BD087705E81ACB48EAD        | 1 / 8 chance[^0]    |\n///  | Theme[^3]      | B/W       | 0x000000FFFFFFFFFFFFFFFFFF000000        | 1 / 8 chance[^0]    |\n///  | (8 traits)     | Candycorn | 0x0D3B66F4D35EEE964BFAF0CAF95738        | 1 / 8 chance[^0]    |\n///  |                | RGB       | 0xFFFF0000FF000000FFFF0000FFFF00        | 1 / 8 chance[^0]    |\n///  |                | VSCode    | 0x1E1E1E569CD6D2D1A2BA7FB54DC4AC        | 1 / 8 chance[^0]    |\n///  |                | Neon      | 0x00FFFFFFFF000000FF00FF00FF00FF        | 1 / 8 chance[^0]    |\n///  |                | Jungle    | 0xBE3400015045020D22EABAACBE3400        | 1 / 8 chance[^0]    |\n///  |                | Corn      | 0xF9C233705860211A28346830F9C233        | 1 / 8 chance[^0]    |\n///  | -------------- | --------- | --------------------------------------- | ------------------- |\n///  | Bit Border[^4] | True      | The bits have a 1px solid black border  | Any pieces captured |\n///  | (2 traits)     | False     | The bits don't have any border          | No pieces captuered |\n///  | ============== | ========= | ======================================= | =================== |\n///  | [^0]: Determined from `_seed`.                                                             |\n///  | [^1]: Gap is omitted when dimension is 1 x 1.                                              |\n///  | [^2]: The first 5 color generation traits are algorithms. A base color is generated from   |\n///  | `seed`, and the remaining colors are generated according to the selected algorithm. The    |\n///  | color of the bits is always the complement of the randomly generated base color, and the   |\n///  | background color depends on the algorithm:                                                 |\n///  |     * Uniform: same as the base color;                                                     |\n///  |     * Shades: darkest shade of the base color;                                             |\n///  |     * Tints: lightest shade of the base color;                                             |\n///  |     * Eclipse: same as the base color;                                                     |\n///  |     * Void: complement of the base color.                                                  |\n///  | If the selected color generation trait is \"Curated,\" 1 of 8 pre-curated themes is randomly |\n///  | selected.                                                                                  |\n///  | [^3]: The entries in the 3rd column are bitpacked integers where                           |\n///  |     * the first 24 bits represent the background color,                                    |\n///  |     * the second 24 bits represent the left face's color,                                  |\n///  |     * the third 24 bits represent the right face's color,                                  |\n///  |     * the fourth 24 bits represent the top face's color,                                   |\n///  |     * and the last 24 bits represent the bits' color.                                      |\n///  | [^4]: Bit border is omitted when dimension is 12 x 12.                                     |\nlibrary fiveoutofnineART{\n    using Strings for uint256;\n    using Chess for uint256;\n\n    string internal constant SVG_STYLES = \"--n:calc((394px - (var(--b) - 1)*var(--c))/var(--b));--o\"\n        \":calc(106px + var(--n));--p:calc(var(--a)/2)}section{height:var(--a);width:var(--a);backgr\"\n        \"ound:var(--e);position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden}.c{height:0;\"\n        \"width:0;position:absolute;transition:0.25s}.c:hover{transform:translate(0px,-64px);transit\"\n        \"ion:0.25s}.c>*{height:var(--n);width:var(--n);border-bottom:4px solid black;border-right:4\"\n        \"px solid black;border-left:1px solid black;border-top:1px solid black;transform-origin:0 0\"\n        \";position:relative;box-sizing:border-box}.c>*:nth-child(1){width:var(--d);background-color\"\n        \":var(--f);transform:rotate(90deg)skewX(-30deg)scaleY(0.864)}.c>*:nth-child(2){height:var(-\"\n        \"-d);bottom:var(--n);background-color:var(--g);transform:rotate(-30deg)skewX(-30deg)scaleY(\"\n        \"0.864)}#h{background-color:var(--h)}#i{background-color:var(--i)}.c>*:nth-child(3){bottom:\"\n        \"calc(var(--d) + var(--n));background-color:var(--h);display:grid;grid-template-columns:rep\" \"eat(\";\n    bytes32 internal constant HEXADECIMAL_DIGITS = \"0123456789ABCDEF\";\n    bytes32 internal constant FILE_NAMES = \"abcdef\";\n\n    /// @notice Takes in data for a given fiveoutofnine NFT and outputs its metadata in JSON form.\n    /// Refer to {fiveoutofnineART} for details.\n    /// @dev The output is base 64-encoded.\n    /// @param _internalId A bitpacked uint256 where the first 128 bits are the game ID, and the\n    /// last 128 bits are the move ID within the game.\n    /// @param _move A struct with information about the player's move and engine's response (see\n    /// {Chess-Move}).\n    /// @return Base 64-encoded JSON of metadata generated from `_internalId` and `_move`.\n    function getMetadata(uint256 _internalId, Chess.Move memory _move) internal pure returns (string memory) {\n        string memory description;\n        string memory image;\n        string memory attributes;\n        uint256 whiteMove;\n        uint256 blackMove;\n        uint256 boardAfterWhiteMove;\n        uint256 boardAfterBlackMove;\n        bool whiteCaptures;\n        bool blackCaptures;\n        uint256 depth;\n\n        {\n            // whiteMove = (_move.metadata >> 0xC) & 0xFFF;\n            // blackMove = _move.metadata & 0xFFF;\n\n            // boardAfterWhiteMove = _move.board.applyMove(whiteMove);\n            // boardAfterBlackMove = boardAfterWhiteMove.applyMove(blackMove);\n\n            // whiteCaptures = _move.board.isCapture(_move.board >> ((whiteMove & 0x3F) << 2));\n            // blackCaptures = boardAfterWhiteMove.isCapture(boardAfterWhiteMove >> ((blackMove & 0x3F) << 2));\n\n            depth = _move.metadata >> 0x18;\n        }\n\n        {\n            uint256 numSquares;\n            {\n                // uint256 whitePieceType = (_move.board >> ((whiteMove >> 6) << 2)) & 7;\n                // uint256 blackPieceType = (boardAfterWhiteMove >> ((blackMove >> 6) << 2)) & 7;\n\n                numSquares = 6;\n                // if (whitePieceType == 1) numSquares = 6;\n                // else if (whitePieceType == 3) numSquares = 2;\n                // else if (whitePieceType == 4) numSquares = 4;\n                // else if (whitePieceType == 5) numSquares = 12;\n                // else numSquares = 1;\n                // if (blackPieceType == 2) numSquares = 3;\n            }\n\n            uint256 seed = uint256(keccak256(abi.encodePacked(_internalId, boardAfterBlackMove, _move.metadata)));\n\n            (image, attributes) = getImage(_move.board, numSquares, seed, whiteCaptures || blackCaptures);\n        }\n\n        // Lots of unusual identation and braces to get around the 16 local variable limitation.\n        {\n            // description = string(\n            //     abi.encodePacked(\n            //         \"---\\\\n\\\\n**Player** plays **`\",\n            //         indexToPosition(whiteMove >> 6, true),\n            //         \"` \",\n            //         getPieceName((_move.board >> ((whiteMove >> 6) << 2)) & 7),\n            //         \"**\",\n            //         whiteCaptures ? \" captures \" : \" to \",\n            //         \"**`\",\n            //         indexToPosition(whiteMove & 0x3F, true)\n            //     )\n            // );\n        }\n        {\n            // description = string(\n            //     abi.encodePacked(\n            //         description,\n            //         \"`\",\n            //         whiteCaptures ? \" \" : \"\",\n            //         whiteCaptures ? getPieceName((_move.board >> ((whiteMove & 0x3F) << 2)) & 7) : \"\",\n            //         \"**.\\\\n\\\\n\",\n            //         drawMove(boardAfterWhiteMove, whiteMove >> 6),\n            //         \"\\\\n\\\\n---\\\\n\\\\n**fiveoutofnine** \"\n            //     )\n            // );\n        }\n\n        {\n            // if (blackMove == 0) {\n            //     description = string(abi.encodePacked(description, \"**resigns**.\"));\n            // } else {\n            //     description = string(\n            //         abi.encodePacked(\n            //             description,\n            //             \"responds with **`\",\n            //             indexToPosition(blackMove >> 6, false),\n            //             \"` \",\n            //             getPieceName((boardAfterWhiteMove >> ((blackMove >> 6) << 2)) & 7),\n            //             \"**\",\n            //             blackCaptures ? \" captures \" : \" to \",\n            //             \"**`\",\n            //             indexToPosition(blackMove & 0x3F, false),\n            //             \"`\",\n            //             blackCaptures ? \" \" : \"\",\n            //             blackCaptures ? getPieceName((boardAfterWhiteMove >> ((blackMove & 0x3F) << 2)) & 7) : \"\",\n            //             \"**.\\\\n\\\\n\",\n            //             drawMove(boardAfterBlackMove, blackMove >> 6)\n            //         )\n            //     );\n            // }\n        }\n\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(\n                    abi.encodePacked(\n                        '{\"name\":\"Game #',\n                        Strings.toString(_internalId >> 0x80),\n                        \", Move #\",\n                        Strings.toString(uint128(_internalId)),\n                        '\",' '\"description\":\"',\n                        description,\n                        '\",\"animation_url\":\"data:text/html;base64,',\n                        image,\n                        '\",\"attributes\":[{\"trait_type\":\"Depth\",\"value\":',\n                        depth.toString(),\n                        \"},\",\n                        attributes,\n                        \"]}\"\n                    )\n                )\n            )\n        );\n    }\n\n    /// @notice Generates the HTML image and its attributes for a given board/seed according to the\n    /// table described in {fiveoutofnineART}.\n    /// @dev The output of the image is base 64-encoded.\n    /// @param _board The board after the player's and engine's move are played.\n    /// @param _numSquares The dimension of the board.\n    /// @param _seed A hash of the game ID, move ID, board position, and metadata.\n    /// @param _pieceCaptured Whether or not any piees were captured.\n    /// @return Base 64-encoded image (in HTML) and its attributes.\n    function getImage(uint256 _board, uint256 _numSquares, uint256 _seed, bool _pieceCaptured)\n        internal\n        pure\n        returns (string memory, string memory)\n    {\n        string memory attributes = string(\n            abi.encodePacked(\n                '{\"trait_type\":\"Dimension\",\"value\":\"',\n                _numSquares.toString(),\n                unicode\" × \",\n                _numSquares.toString(),\n                '\"}'\n            )\n        );\n        string memory styles = string(abi.encodePacked(\"<style>:root{--a:1000px;--b:\", _numSquares.toString(), \";--c:\"));\n\n        {\n            string memory tempAttribute;\n            string memory tempValue = \"0\";\n            if (_numSquares != 1) {\n                if (_seed & 0xF < 4) (tempAttribute, tempValue) = (\"None\", \"0\");\n                else if (_seed & 0xF < 13) (tempAttribute, tempValue) = (\"Narrow\", \"2\");\n                else if (_seed & 0xF < 15) (tempAttribute, tempValue) = (\"Wide\", \"12\");\n                else (tempAttribute, tempValue) = (\"Ultrawide\", \"24\");\n\n                attributes = string(abi.encodePacked(attributes, ',{\"trait_type\":\"Gap\",\"value\":\"', tempAttribute, '\"}'));\n            }\n            styles = string(abi.encodePacked(styles, tempValue, \"px;--d:\"));\n        }\n        _seed >>= 4;\n\n        {\n            string memory tempAttribute;\n            string memory tempValue;\n            if (_seed & 0x3F < 1) (tempAttribute, tempValue) = (\"Plane\", \"8\");\n            else if (_seed & 0x3F < 11) (tempAttribute, tempValue) = (\"1/4\", \"98\");\n            else if (_seed & 0x3F < 21) (tempAttribute, tempValue) = (\"1/2\", \"197\");\n            else if (_seed & 0x3F < 51) (tempAttribute, tempValue) = (\"Cube\", \"394\");\n            else (tempAttribute, tempValue) = (\"Infinite\", \"1000\");\n\n            attributes = string(abi.encodePacked(attributes, ',{\"trait_type\":\"Height\",\"value\":\"', tempAttribute, '\"}'));\n            styles = string(abi.encodePacked(styles, tempValue, \"px;\"));\n        }\n        _seed >>= 6;\n\n        {\n            string memory tempAttribute;\n            uint256 colorTheme;\n            if (_seed & 0x1F < 25) {\n                colorTheme = (_seed >> 5) & 0xFFFFFF;\n                attributes = string(\n                    abi.encodePacked(attributes, ',{\"trait_type\":\"Base Color\",\"value\":', colorTheme.toString(), \"}\")\n                );\n                if (_seed & 0x1F < 7) {\n                    tempAttribute = \"Uniform\";\n                    colorTheme = (colorTheme << 0x60) | (colorTheme << 0x48) | (colorTheme << 0x30)\n                        | (colorTheme << 0x18) | complementColor(colorTheme);\n                } else if (_seed & 0x1F < 14) {\n                    tempAttribute = \"Shades\";\n                    colorTheme = (darkenColor(colorTheme, 3) << 0x60) | (darkenColor(colorTheme, 1) << 0x48)\n                        | (darkenColor(colorTheme, 2) << 0x30) | (colorTheme << 0x18) | complementColor(colorTheme);\n                } else if (_seed & 0x1F < 21) {\n                    tempAttribute = \"Tints\";\n                    colorTheme = (brightenColor(colorTheme, 3) << 0x60) | (brightenColor(colorTheme, 1) << 0x48)\n                        | (brightenColor(colorTheme, 2) << 0x30) | (colorTheme << 0x18) | complementColor(colorTheme);\n                } else if (_seed & 0x1F < 24) {\n                    tempAttribute = \"Eclipse\";\n                    colorTheme =\n                        (colorTheme << 0x60) | (0xFFFFFF << 0x48) | (colorTheme << 0x18) | complementColor(colorTheme);\n                } else {\n                    tempAttribute = \"Void\";\n                    colorTheme =\n                        (complementColor(colorTheme) << 0x60) | (colorTheme << 0x18) | complementColor(colorTheme);\n                }\n            } else {\n                tempAttribute = \"Curated\";\n                _seed >>= 5;\n\n                attributes = string(\n                    abi.encodePacked(\n                        attributes,\n                        ',{\"trait_type\":\"Color Theme\",\"value\":\"',\n                        [\"Nord\", \"B/W\", \"Candycorn\", \"RGB\", \"VSCode\", \"Neon\", \"Jungle\", \"Corn\"][_seed & 7],\n                        '\"}'\n                    )\n                );\n\n                colorTheme = [\n                    0x8FBCBBEBCB8BD087705E81ACB48EAD000000FFFFFFFFFFFFFFFFFF000000,\n                    0x0D3B66F4D35EEE964BFAF0CAF95738FFFF0000FF000000FFFF0000FFFF00,\n                    0x1E1E1E569CD6D2D1A2BA7FB54DC4AC00FFFFFFFF000000FF00FF00FF00FF,\n                    0xBE3400015045020D22EABAACBE3400F9C233705860211A28346830F9C233\n                ][(_seed & 7) >> 1];\n                colorTheme = _seed & 1 == 0 ? colorTheme >> 0x78 : colorTheme & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n            }\n            attributes =\n                string(abi.encodePacked(attributes, ',{\"trait_type\":\"Color Generation\",\"value\":\"', tempAttribute, '\"}'));\n            styles = string(\n                abi.encodePacked(\n                    styles,\n                    \"--e:\",\n                    toColorHexString(colorTheme >> 0x60),\n                    \";--f:\",\n                    toColorHexString((colorTheme >> 0x48) & 0xFFFFFF),\n                    \";--g:\",\n                    toColorHexString((colorTheme >> 0x30) & 0xFFFFFF),\n                    \";--h:\",\n                    toColorHexString((colorTheme >> 0x18) & 0xFFFFFF),\n                    \";--i:\",\n                    toColorHexString(colorTheme & 0xFFFFFF),\n                    \";\"\n                )\n            );\n        }\n\n        {\n            string memory tempAttribute;\n            styles = string(\n                abi.encodePacked(\n                    styles,\n                    SVG_STYLES,\n                    Strings.toString(12 / _numSquares),\n                    \",1fr);grid-template-rows:repeat(\",\n                    Strings.toString(12 / _numSquares),\n                    \",1fr);transform:rotate(210deg)skew(-30deg)scaleY(0.864)}\"\n                )\n            );\n            if (_numSquares != 12) {\n                if (_pieceCaptured) {\n                    tempAttribute = \"True\";\n                    styles = string(abi.encodePacked(styles, \".c>*:nth-child(3)>div{border: 1px solid black}\"));\n                } else {\n                    tempAttribute = \"False\";\n                }\n                attributes =\n                    string(abi.encodePacked(attributes, ',{\"trait_type\":\"Bit Border\",\"value\":\"', tempAttribute, '\"}'));\n            }\n        }\n\n        unchecked {\n            for (uint256 i; i < 23; ++i) {\n                styles = string(\n                    abi.encodePacked(\n                        styles,\n                        \".r\",\n                        i.toString(),\n                        \"{top:calc(var(--o) + \",\n                        i.toString(),\n                        \"*(var(--n)/2 + var(--c)))}\" \".c\",\n                        i.toString(),\n                        \"{left:calc(var(--p) \",\n                        i < 11 ? \"-\" : \"+\",\n                        \" 0.866*\",\n                        i < 11 ? (11 - i).toString() : (i - 11).toString(),\n                        \"*(var(--n) + var(--c)))}\"\n                    )\n                );\n            }\n\n            string memory image;\n            for (uint256 row; row < (_numSquares << 1) - 1; ++row) {\n                uint256 tempCol = row <= _numSquares - 1 ? 11 - row : 11 - ((_numSquares << 1) - 2 - row);\n                for (\n                    uint256 col = tempCol;\n                    col\n                        <= (row <= _numSquares - 1 ? tempCol + (row << 1) : tempCol + (((_numSquares << 1) - 2 - row) << 1));\n                    col = col + 2\n                ) {\n                    image = string(abi.encodePacked(image, getPillarHtml(_board, 12 / _numSquares, row, col)));\n                }\n            }\n\n            return (Base64.encode(abi.encodePacked(styles, \"</style><section>\", image, \"</section>\")), attributes);\n        }\n    }\n\n    /// @notice Returns the HTML for a particular pillar within the image.\n    /// @param _board The board after the player's and engine's move are played.\n    /// @param _dim The dimension of the bits within a pillar.\n    /// @param _row The row index of the pillar.\n    /// @param _col The column index of the pillar.\n    /// @return The HTML for the pillar described by the parameters.\n    function getPillarHtml(uint256 _board, uint256 _dim, uint256 _row, uint256 _col)\n        internal\n        pure\n        returns (string memory)\n    {\n        string memory pillar = string(\n            abi.encodePacked('<div class=\"c r', _row.toString(), \" c\", _col.toString(), '\"><div></div><div></div><div>')\n        );\n\n        uint256 x;\n        uint256 y;\n        uint256 colOffset;\n        uint256 rowOffset;\n        unchecked {\n            for (uint256 subRow = _row * _dim + ((_dim - 1) << 1); subRow >= _row * _dim + (_dim - 1); --subRow) {\n                rowOffset = 0;\n                uint256 tempSubCol =\n                    _col <= 11 ? 11 - _dim * (11 - _col) + colOffset : 11 + _dim * (_col - 11) + colOffset;\n                for (uint256 subCol = tempSubCol; subCol >= tempSubCol + 1 - _dim; --subCol) {\n                    x = 11 - ((11 + subCol - (subRow - rowOffset)) >> 1);\n                    y = 16 - ((subCol + subRow - rowOffset) >> 1);\n                    pillar = string(\n                        abi.encodePacked(\n                            pillar,\n                            '<div id=\"',\n                            (\n                                _board >> (Chess.getAdjustedIndex(6 * (y >> 1) + (x >> 1)) << 2)\n                                    >> (((0xD8 >> ((x & 1) << 2)) >> ((y & 1) << 1)) & 3)\n                            ) & 1 == 0 ? \"h\" : \"i\",\n                            '\"></div>'\n                        )\n                    );\n                    rowOffset++;\n                    if (subCol == 0) break;\n                }\n                colOffset++;\n                if (subRow == 0) break;\n            }\n        }\n\n        return string(abi.encodePacked(pillar, \"</div></div>\"));\n    }\n\n    /// @notice Draws out a move being played out on a board position as a string with unicode\n    /// characters to represent pieces. Files and rows are labeled with standard algebraic\n    /// notation. For example:\n    /// ```\n    /// 6 ♜ ♝ ♛ ♚ ♝ ♜\n    /// 5 ♟ ♟ ♟ ♟ ♟ ♟\n    /// 4 · · · · · ·\n    /// 3 · · ♙ · · ·\n    /// 2 ♙ ♙ * ♙ ♙ ♙\n    /// 1 ♖ ♘ ♕ ♔ ♘ ♖\n    ///  a b c d e f\n    /// ```\n    /// * indicates the square the piece moved from.\n    /// @param _board The board the move is played on.\n    /// @param _fromIndex The from index of the move.\n    /// @return The string showing the move played out on the board.\n    function drawMove(uint256 _board, uint256 _fromIndex) internal pure returns (string memory) {\n        string memory boardString = \"```\\\\n\";\n\n        if (_board & 1 == 0) _board = _board.rotate();\n        else _fromIndex = ((7 - (_fromIndex >> 3)) << 3) + (7 - (_fromIndex & 7));\n\n        for (uint256 index = 0x24A2CC34E4524D455665A6DC75E8628E4966A6AAECB6EC72CF4D76; index != 0; index >>= 6) {\n            uint256 indexToDraw = index & 0x3F;\n            boardString = string(\n                abi.encodePacked(\n                    boardString,\n                    indexToDraw & 7 == 6 ? string(abi.encodePacked(Strings.toString((indexToDraw >> 3)), \" \")) : \"\",\n                    indexToDraw == _fromIndex ? \"*\" : getPieceChar((_board >> (indexToDraw << 2)) & 0xF),\n                    indexToDraw & 7 == 1 && indexToDraw != 9 ? \"\\\\n\" : indexToDraw != 9 ? \" \" : \"\"\n                )\n            );\n        }\n\n        boardString = string(abi.encodePacked(boardString, \"\\\\n  a b c d e f\\\\n```\"));\n\n        return boardString;\n    }\n\n    /// @notice Computes the complement of 24-bit colors.\n    /// @param _color A 24-bit color.\n    /// @return The complement of `_color`.\n    function complementColor(uint256 _color) internal pure returns (uint256) {\n        unchecked {\n            return 0xFFFFFF - _color;\n        }\n    }\n\n    /// @notice Darkens 24-bit colors.\n    /// @param _color A 24-bit color.\n    /// @param _num The number of shades to darken by.\n    /// @return `_color` darkened `_num` times.\n    function darkenColor(uint256 _color, uint256 _num) internal pure returns (uint256) {\n        return\n            (((_color >> 0x10) >> _num) << 0x10) | ((((_color >> 8) & 0xFF) >> _num) << 8) | ((_color & 0xFF) >> _num);\n    }\n\n    /// @notice Brightens 24-bit colors.\n    /// @param _color A 24-bit color.\n    /// @param _num The number of tints to brighten by.\n    /// @return `_color` brightened `_num` times.\n    function brightenColor(uint256 _color, uint256 _num) internal pure returns (uint256) {\n        unchecked {\n            return ((0xFF - ((0xFF - (_color >> 0x10)) >> _num)) << 0x10)\n                | ((0xFF - ((0xFF - ((_color >> 8) & 0xFF)) >> _num)) << 8) | (0xFF - ((0xFF - (_color & 0xFF)) >> _num));\n        }\n    }\n\n    /// @notice Returns the color hex string of a 24-bit color.\n    /// @param _integer A 24-bit color.\n    /// @return The color hex string of `_integer`.\n    function toColorHexString(uint256 _integer) internal pure returns (string memory) {\n        return string(\n            abi.encodePacked(\n                \"#\",\n                HEXADECIMAL_DIGITS[(_integer >> 0x14) & 0xF],\n                HEXADECIMAL_DIGITS[(_integer >> 0x10) & 0xF],\n                HEXADECIMAL_DIGITS[(_integer >> 0xC) & 0xF],\n                HEXADECIMAL_DIGITS[(_integer >> 8) & 0xF],\n                HEXADECIMAL_DIGITS[(_integer >> 4) & 0xF],\n                HEXADECIMAL_DIGITS[_integer & 0xF]\n            )\n        );\n    }\n\n    /// @notice Maps piece type to its corresponding name.\n    /// @param _type A piece type defined in {Chess}.\n    /// @return The name corresponding to `_type`.\n    function getPieceName(uint256 _type) internal pure returns (string memory) {\n        if (_type == 1) return \"pawn\";\n        else if (_type == 2) return \"bishop\";\n        else if (_type == 3) return \"rook\";\n        else if (_type == 4) return \"knight\";\n        else if (_type == 5) return \"queen\";\n        return \"king\";\n    }\n\n    /// @notice Converts a position's index to algebraic notation.\n    /// @param _index The index of the position.\n    /// @param _isWhite Whether the piece is being determined for a white piece or not.\n    /// @return The algebraic notation of `_index`.\n    function indexToPosition(uint256 _index, bool _isWhite) internal pure returns (string memory) {\n        unchecked {\n            return _isWhite\n                ? string(abi.encodePacked(FILE_NAMES[6 - (_index & 7)], Strings.toString(_index >> 3)))\n                : string(abi.encodePacked(FILE_NAMES[(_index & 7) - 1], Strings.toString(7 - (_index >> 3))));\n        }\n    }\n\n    /// @notice Maps pieces to its corresponding unicode character.\n    /// @param _piece A piece.\n    /// @return The unicode character corresponding to `_piece`. It returns ``.'' otherwise.\n    function getPieceChar(uint256 _piece) internal pure returns (string memory) {\n        if (_piece == 1) return unicode\"♟\";\n        if (_piece == 2) return unicode\"♝\";\n        if (_piece == 3) return unicode\"♜\";\n        if (_piece == 4) return unicode\"♞\";\n        if (_piece == 5) return unicode\"♛\";\n        if (_piece == 6) return unicode\"♚\";\n        if (_piece == 9) return unicode\"♙\";\n        if (_piece == 0xA) return unicode\"♗\";\n        if (_piece == 0xB) return unicode\"♖\";\n        if (_piece == 0xC) return unicode\"♘\";\n        if (_piece == 0xD) return unicode\"♕\";\n        if (_piece == 0xE) return unicode\"♔\";\n        return unicode\"·\";\n    }\n}\n"
    },
    "contracts/Board.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {Elo} from \"./library/Elo.sol\";\nimport {fiveoutofnineART, Chess} from \"./art/fiveOutOfNineArt.sol\";\nimport {IBoard} from \"./interfaces/IBoard.sol\";\n\ncontract Board is IBoard, ERC1155, Ownable{\n    uint256 constant TOKEN_PRICE = 0.02 ether; // Token price of minting an NFT for a solved puzzle\n    uint256 constant CREATOR_SPLIT = 15; // Percent of token price that goes to creator (e.g. 15 = 15%)\n    uint256 constant K_FACTOR = 25e18; //  How quickly elo is adjusted\n    uint256 constant RATING_FLOOR = 100e18; // Minimum rating a person or puzzle can have\n    uint256 constant DEFAULT_RATING = 1000e18; // Minimum rating a person or puzzle can have\n    uint16 public puzzleCounter;\n    uint256 public tokenCount; \n\n    struct Puzzle {\n        string fen;\n        bytes32 solutionHash; // Hash of the solution\n        uint256 solveCount; \n        uint256 attemptCount; \n        mapping(address => bool) userHasSolved;\n        mapping(address => bool) userHasAttempted;\n        uint256 rating;\n        Chess.Move move; // Used to generate nft art\n        address creator ;\n    }\n\n    mapping(uint16 => Puzzle) public puzzlesById;\n    mapping(address => uint256 ) public userRatings;\n    mapping(uint256 => uint16) public tokenIdToPuzzleId;\n\n    error StringCannotBeEmpty(string s);\n    error BytesCannotBeEmpty(bytes32 b);\n    error InvalidPuzzle(uint16 puzzleId );\n    error AlreadyAttempted(uint16 puzzleId);\n    error PuzzleNotSolved(uint16 puzzleId);\n    error TokenDoesNotExist(uint256 tokenId);\n    error NotEnoughEtherSent(uint256 amountSent, uint256 requiredAmount);\n    error InvalidPuzzleMove(uint16 puzzleId);\n\n    constructor(address initialOwner) Ownable(initialOwner) ERC1155(\"\") {}\n\n    function userHasSolvedPuzzle(uint16 puzzleId, address user) public view returns (bool) {\n        return puzzlesById[puzzleId].userHasSolved[user];\n    }\n\n    function uri(uint256 _tokenId) public view override returns (string memory) {\n        if(_tokenId >= tokenCount){\n            revert TokenDoesNotExist(_tokenId);\n        }\n        uint16 _puzzleId = tokenIdToPuzzleId[_tokenId];\n        return fiveoutofnineART.getMetadata(_puzzleId, puzzlesById[_puzzleId].move);\n    }\n\n\n    function mint(uint16 puzzleId) public payable{\n        if(msg.value < TOKEN_PRICE){\n            revert NotEnoughEtherSent(msg.value, TOKEN_PRICE);\n        }\n        Puzzle storage puzzle =puzzlesById[puzzleId];\n        if(!puzzle.userHasSolved[_msgSender()]){\n            revert PuzzleNotSolved(puzzleId);\n        }\n\n        uint256 tokenCount_ = tokenCount; // Cache for gas savings\n        tokenIdToPuzzleId[tokenCount_] = puzzleId;\n        tokenCount = tokenCount_ + 1;\n        _mint(_msgSender(),  puzzleId, 1, \"\");\n        emit TokenMinted(puzzleId, _msgSender(), tokenCount_);\n        payable(puzzle.creator).transfer(msg.value* CREATOR_SPLIT / 100);\n    }\n\n    function addPuzzle(string memory fen, bytes32 solutionHash, Chess.Move memory move) public{\n        if(bytes(fen).length == 0){\n            revert StringCannotBeEmpty(fen);\n        }\n        if((solutionHash).length ==0){\n            revert BytesCannotBeEmpty(solutionHash);\n        } \n        if(move.board ==0 || move.metadata==0){\n            revert InvalidPuzzleMove(puzzleCounter);\n        }\n\n        // Call to ensure that getMetadata is valid\n        fiveoutofnineART.getMetadata(puzzleCounter, move);\n\n        uint16 puzzleId = puzzleCounter;\n        Puzzle storage puzzle = puzzlesById[puzzleId];\n        puzzle.fen = fen;\n        puzzle.solutionHash = solutionHash;\n        puzzle.creator = _msgSender();\n        puzzle.rating = DEFAULT_RATING;\n        puzzle.move = move;\n        puzzleCounter = puzzleCounter + 1;\n\n        emit PuzzleAdded(puzzleId, fen, solutionHash, move.board, move.metadata, _msgSender());\n    }\n\n    function submitSolution(uint16 puzzleId, bytes memory solution) public returns (bool) {\n        if(puzzleId >= puzzleCounter){\n            revert InvalidPuzzle(puzzleId);\n        }\n\n        Puzzle storage puzzle = puzzlesById[puzzleId];\n\n        if(puzzle.userHasAttempted[_msgSender()]){\n            revert AlreadyAttempted(puzzleId);\n        }\n\n        \n        emit PuzzleAttempted(puzzleId, _msgSender(), solution);\n\n        puzzle.userHasAttempted[_msgSender()] = true;\n        puzzle.attemptCount += 1;\n        // cache ratings for gas savings\n        uint256 userRating  = userRatings[_msgSender()];\n        userRating = userRating > 0? userRating : DEFAULT_RATING;\n        uint256 puzzleRating = puzzle.rating; \n\n        if (puzzle.solutionHash == keccak256(solution)) {\n            puzzle.userHasSolved[_msgSender()] = true;\n            puzzle.solveCount += 1;\n            (uint256 ratingAdjustment, ) = Elo.calculateEloUpdate(userRating, puzzleRating, 1e18, K_FACTOR);\n            userRatings[_msgSender()] = userRating + ratingAdjustment;\n            if(puzzleRating > RATING_FLOOR + ratingAdjustment){\n                puzzle.rating = puzzleRating - ratingAdjustment;\n                emit PuzzleRatingChanged(puzzleId, puzzleRating - ratingAdjustment); \n            }\n            else{\n                puzzle.rating = RATING_FLOOR; \n                emit PuzzleRatingChanged(puzzleId, RATING_FLOOR);\n            }\n\n            emit PuzzleSolved(puzzleId, _msgSender());\n            emit UserRatingChanged(_msgSender(), puzzleRating + ratingAdjustment);\n            return true;\n        } else {\n            (uint256 ratingAdjustment, ) = Elo.calculateEloUpdate(userRating, puzzleRating, 0, K_FACTOR);\n            puzzle.rating = puzzleRating + ratingAdjustment;\n            if(userRating > RATING_FLOOR + ratingAdjustment){\n                userRatings[_msgSender()] = userRating - ratingAdjustment;\n                emit UserRatingChanged(_msgSender(), puzzleRating - ratingAdjustment); \n            }\n            else{\n                userRatings[_msgSender()] = RATING_FLOOR;\n                emit UserRatingChanged(_msgSender(), RATING_FLOOR); \n            }\n\n            emit PuzzleRatingChanged(puzzleId, puzzleRating + ratingAdjustment);\n            return false;\n        }\n    }\n\n    function withdraw() public onlyOwner{\n        uint256 amount = address(this).balance;\n        payable(_msgSender()).transfer(amount);\n        emit Withdraw(_msgSender(), amount);\n    }\n}\n"
    },
    "contracts/interfaces/IBoard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Chess} from \"../art/Chess.sol\";\n\ninterface IBoard {\n    event PuzzleAdded(uint16 puzzleId, string fen, bytes32 solutionHash, uint256 board, uint256 metadata, address creator); \n    event PuzzleSolved(uint16 puzzleId, address user);\n    event PuzzleAttempted(uint16 puzzleId, address user, bytes solutionSubmission);\n    event UserRatingChanged(address user, uint256 newUserRating);\n    event PuzzleRatingChanged(uint16 puzzleId, uint256 newPuzzleRating);\n    event TokenMinted(uint16 puzzleId, address solver, uint256 tokenId); \n    event Withdraw(address owner, uint256 amount);\n\n    function userHasSolvedPuzzle(uint16 puzzleId, address user) external view returns (bool);\n    function mint(uint16 puzzleId) external payable;\n    function addPuzzle(string memory fen, bytes32 solutionHash, Chess.Move memory move) external;\n    function submitSolution(uint16 puzzleId, bytes memory solution) external returns (bool);\n    function withdraw() external;\n}\n"
    },
    "contracts/library/Elo.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\nimport {PRBMathUD60x18} from \"prb-math/contracts/PRBMathUD60x18.sol\";\n\n/**\n * @title Elo\n * @dev Library for calculating Elo ratings. Can be used for any zero-sum.\n * @dev uses 400 as the rating spread (i.e. every 400 difference in rating between is a factor of 10 difference in  win probability)\n * @dev All numbers are represented as fixed point numbers with 18 decimals (i.e. D.60.18)\n */\n\nlibrary Elo {\n\n    /**\n     * @dev Calculates how much scores of player A needs to be updated after a batch with player B\n     * @dev All input and output numbers are represented as fixed point numbers with 18 decimals (i.e. D60.18)\n     * @dev To get how much B's score needs to be update, take negative of the returned value\n     * @dev returns the amount that A's elo changes, and a boolean that signifies if it's a negative or positive change\n     */\n    function calculateEloUpdate(uint256 ratingA, uint256 ratingB, uint256 scoreA, uint256 k)internal pure returns (uint256 , bool){\n        uint256 ratingDiff;\n        bool comparison = ratingA>= ratingB; \n        if(comparison){\n            ratingDiff = ratingA - ratingB;\n        }\n        else{\n            ratingDiff =  ratingB - ratingA;\n        }\n\n        uint256 exp = comparison ? \n            PRBMathUD60x18.div(1e18 , PRBMathUD60x18.pow(10e18, ratingDiff /400)):\n            PRBMathUD60x18.pow(10e18, ratingDiff /400); \n\n        uint256 Ea = PRBMathUD60x18.div(1e18, 1e18 + exp);  // expected value of A at current rating\n        if(scoreA > Ea){\n            ratingDiff = PRBMathUD60x18.mul( k, scoreA - Ea);\n            return (ratingDiff, true);\n        }\n        else{\n            ratingDiff = PRBMathUD60x18.mul( k, Ea - scoreA );\n            return (ratingDiff, false);\n        }\n\n    }\n\n}"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "prb-math/contracts/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}